---
title: "PostgreSQLのデータの物理的な保存とログ先行書き込みについて"
date: "2020-05-26"
tags: ["PostgreSQL"]
---

## はじめに

PostgreSQLで保存されるテーブルのレコードなどは物理的にはファイルとして保存されるが、どこに、どのように、どのタイミングで保存されるかを調べてみました。
PostgreSQLのバージョンは11です。

## テーブルファイルの構造

まず試しに空のテーブルを作り、作成したテーブルのファイルノード番号を取得します。
ファイルノード番号とはテーブルデータファイルのIDのようなもので、テーブルデータのファイル名にもなります。

```sql
create table sample (id int);
select relname, relfilenode from pg_class where relname = 'sample';
 relname | relfilenode
---------+-------------
 sample  |       24622

-- 下記のようにテーブルファイルのパスを取得することもできる。
select pg_relation_filepath('sample');
 pg_relation_filepath
----------------------
 base/13091/24622
```

このテーブルファイル名でデータベースの物理テーブルファイルを保存している場所を探してみます。
テーブルファイルは`$PGDATA/base/`内に保存されています。
`$PGDATA`は多くの場合`/var/lib/postgresql/11/main/`などです。
baseディレクトリはデータベースごとに下記のファイルが格納されます。

|名称|説明|
|:--|:--|
|テーブルファイル|テーブルデータの実体が格納される。8192バイトの「ページ」と呼ばれる単位で構成される|
|インデックスファイル|検索性能向上のインデックス情報が格納される。こちらも8192バイトの「ページ」単位で構成される|
|TOASTファイル|テーブル内の巨大な行（通常は2kB以上）をテーブルファイルとは別で格納するためのもの|
|Free Space Mapファイル|空き領域を追跡するための情報が格納されたファイル|
|Visiblity Mapファイル|テーブルの可視性を管理するファイル|

当然ながら物理データファイルが格納されるディレクトリの中でも最も重要なディレクトリになります。
baseディレクトリ直下はデータベースのoidを名前としたディレクトリが配置されており、その中に上のファイルが格納されています。
データベースのoidはpg_databaseテーブルから取得できます。

```sql
select oid, datname from pg_database where datname = 'postgres';
  oid  | datname
-------+----------
 13091 | postgres
```

今回はpostgresデータベースにテーブルを作成したので、`base/13091`ディレクトリを確認すればよいことがわかります。

```sh
$ cd /var/lib/postgresql/11/main
$ ls -la ./base/13091/24622 
-rw------- 1 postgres postgres      0 May 23 22:34 24622
```

ありました。
テーブルファイルは存在したがファイルサイズが0なのでまだ何も書き込まれていません。
テーブルを作成しただけでレコードがない段階では、まだメタデータしか存在しないのでテーブルファイル自体は空のようです。

次に先程作成した空のテーブルに1行インサートしてみます。

```sql
insert into sample values (1), (2), (3);

root@DESKTOP-J70J3S6:/var/lib/postgresql/11/main# ls -la ./base/13091/24622
-rw------- 1 postgres postgres   8192 May 23 23:45 24622
```

今度はテーブルファイルのサイズが8192バイトになったのでデータの書き込みがなされたことがわかります。
今回インサートしたのはint列1行でしかないためデータとしては実体のデータとしては4バイトしかありませんが、テーブルファイルは8192バイトの「ページ」と呼ばれる単位で構成されるため、8192バイトずつしか増加していきません。
そしてテーブルファイルの1ファイルの上限は1GBまでと決まっており、それ以降は24632.1、24632.2...のように1GBごとにファイルが増えていきます。

テーブルファイルをバイナリエディタで見てみます。
![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/65636/4e708caa-2b44-9685-1b91-f023b375e137.png)
![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/65636/2046f8c9-05b5-a8ae-c3d1-d7cf72194ec9.png)

テーブルファイルは主に次の要素で構成されます。

|名称|説明|
|:--|:--|
|ページヘッダ|自ページの情報を格納する。ページの先頭から24バイト。|
|アイテムIDデータ|更新したデータのメタ情報を格納する。<br>ページヘッダの次からひとつにつき4バイト。|
|アイテムデータ|更新したデータの実体データ情報を格納する。<br>ページの末尾から先頭に向かって格納される。サイズは可変。|
|空き領域|アイテムIDデータとアイテムデータの間の00が連続している領域。<br>ページに更新があるとここにアイテムIDデータとアイテムデータが入る。<br>ここにデータが入らなくなったら新たなページが追加される。|

### アイテムIDデータとアイテムデータ

アイテムIDデータとアイテムデータは対の存在でありページには同じ個数分存在しています。
アイテムIDデータは先頭から順に次の情報が保存されています。

|名称|長さ|内容|
|:--|:--|:--|
|lp_off|15|対応するタプルの開始オフセット|
|lp_flags|2|タプルの状態を示すフラグ（0:未使用, 1:使用中, 2:HOT更新でリダイレクト, 3:無効）|
|lp_len|15|対応するタプルの開始オフセット|

上の画像でいうとアイテムIDデータは`E0 9F 38 00`, `C0 9F 38 00`, `A0 9F 38 00`です。
`E0 9F 38 00`はbitに直すと、`11100000 10011111 00111000 00000000`となります。
これはバイトごとに逆順に格納されているので、上の情報を見るときは`00000000 00111000 10011111 11100000`と並べ替えます。
これで下記のような情報がわかります。()内は10進数に直した数値です。

- lp_off: 001111111100000 (8160)
- lp_flags: 01 (1)
- lp_len: 000000000011100 (28)

つまり、先頭から8160バイトの位置から28バイト分の情報に対応するアイテムデータが存在しており、使用中だということがわかります。
実際に先頭から8160バイトの位置は上の画像でちょうど一番下のオレンジ枠にあたるので正しそうです。
ここでINSERTしたのは`1`というINT列1行なので、データの実体は4バイトしかないがINSERTで格納されたなどの情報も入ってくるのでそれ以上のバイト数が専有されているものと思われます。
PostgreSQLは追記型のアーキテクチャなので、挿入だけでなく更新・削除でもテーブルファイルの実体データには追記されていきます。

### 追記型アーキテクチャ

PostgreSQLが追記型のアーキテクチャというのは図に表すと下記のようなイメージです（あくまでイメージであり実体としては他の情報も記録されているはず）

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/65636/54d63a18-0742-13a9-6d38-516394267b49.png)

アイテムデータは末尾から先頭に向かって下から順に格納されていきます。
id=2のデータは4回目の操作でUPDATEされていますが、もともとINSERT id=2となっていたアイテムを更新するのではなく追記していく形になります。DELETEも同様です。

これを見るとORDER BYをつけなければSELECTでのデータ取得で順序が確定できないイメージできます。
挿入・更新・削除によりテーブルファイル内のデータはバラバラになるので、あくまで論理的なテーブルから取得しているわけではなく物理的なファイルから取得するイメージをすると順序の確定が思ったよりコストのかかる処理であることが理解できます。

### テーブルファイルの性能低下を防ぐVACCUM

更新・削除でもテーブルファイルが増えていくとページ内のアイテムに実際には使用されていないものが増えていきこれが性能低下に繋がることがあります。
これを防ぐためにPostgreSQLでは定期的にVACUUMと呼ばれる処理が行われています。

VACUUMでは各テーブルのページを走査していき、Visiblity Mapファイルをチェックして不要行を含むかを確認しあれば不要行を削除します。また、対象テーブルのインデックスメンテナンスも行います。
そして、削除した行の情報をもとにFree Space Mapファイルを更新します。

大抵はVACUUMでテーブルファイル、インデックスファイルの掃除は行われますが、長期化しているトランザクションがある場合など、定期的なVACUUM実行では対応し切れない場合にVACUUM FULLによるメンテナンスも行います。

定期的なVACUUM中は参照が可能であり、更新もVACUUM中のページ以外での更新は可能なので実質可能ですが、VACUUM FULL中は対象テーブルへの参照・更新はすべて待たされるので注意が必要です。

## ログ先行書き込み

何回かデータをインサートしていきテーブルファイルを確認すると、コミット時点では必ずしもテーブルファイルにデータが追記されていないことに気づきます。
これはいわゆるログ先行書き込みと呼ばれる仕組みによるものです。

ログ先行書き込みとは、テーブルファイルに書き込む前にWAL(Write Ahead Log)ファイルと呼ばれるファイルにまず更新内容を追記し、一定のタイミングでテーブルファイルに後から書き込むことです。

これを行う最も大きな理由はDBのACID属性のひとつ**原子性を担保するため**です。
原子性とは1トランザクション内の処理がすべて実行されるかすべて実行されないかのどちらかとなり、中途半端な状態は許さないことです。

先にWALファイルに書き込んでおけば、途中でクラッシュしてもその内容からテーブルファイルをロールバックしたり、リカバリできたりします。
直接テーブルファイルに書き込むだけだと、途中でクラッシュした場合などには半端な状態が残ってしまいます。

また、コミット時に即WALファイルに書き込むわけではなく、一度WALバッファと呼ばれるメモリ領域に更新内容は保存されます。
つまり、`WALバッファ(メモリ) → WALファイル(ディスク) → テーブルファイル(ディスク)`という順で書き込まれていきます。
上は時間軸的な書き込み順であって、バッファに内容があれば書き込み自体はバッファからテーブルファイルになされたりします。

これは書き込みのパフォーマンスを上げるためで、ディスクへの書き込みはメモリに比べて非常に遅いため、都度ディスクにあるテーブルファイルやWALファイルに書き込むと頻繁な更新がある際に問題となります。
WALバッファに変更を溜め込み、一定のタイミングでWALファイルに書き込むことでディスクへの書き込み回数を減らすことができます。
常に`WALバッファ → テーブルファイル`、ではなくWALファイルが必要なのはメモリは有限で更新内容をすべて保持仕切れるとは限らないからです。
`WALバッファ → WALファイル → テーブルファイル`とすれば、バッファがあふれたときもWALファイルに記録することができます。
またテーブルファイルへの追記は先程見たようにページ内での追記位置を決めていかなければいけませんが、WALファイルは末尾にアペンドしていくだけなのでこちらも速いです。

WALファイルは`pg_wal`ディレクトリに存在しています。
コミット時点で更新日時が更新されているので、テーブルファイルより先にこちらに追記されることがわかります。
また、中身を見ると先頭からしばらくデータが記録されているが途中から空き領域となっているので、テーブルファイルのページ構成と異なり先頭からただ追記していくだけだということもわかります。

```sh
$ ls -l pg_wal/
total 16384
-rw------- 1 postgres postgres 16777216 May 24 15:39 000000010000000000000001
drwx------ 1 postgres postgres     4096 May 24 11:39 archive_status
```

WALファイル、テーブルファイルそれぞれの書き込みタイミングは下記となっています。

### WALファイルへの書き込みタイミング

- COMMIT発行時
- wal writerプロセスの定期実行時
- WALバッファあふれ
- CHECKPOINT, VACUUM実行時
- 共有バッファあふれ

### テーブルファイルへの書き込みタイミング

- CHECKPOINT実行時
- writerプロセスの定期実行時
- 共有バッファあふれ

こちらは下記ページで詳しく説明されていました。
[PostgreSQL WALログの仕組みとタイミングを理解したい](https://www.kimullaa.com/entry/2019/10/28/000000#WAL%E3%81%AE%E6%9B%B8%E3%81%8D%E8%BE%BC%E3%81%BF%E3%82%BF%E3%82%A4%E3%83%9F%E3%83%B3%E3%82%B0)

## インデックス

例えばselectで特定の1行を選択するとき、インデックスが活用されれば取得は速いが、そうでないときは実質テーブルの全行を走査した上で取得するので遅くなってしまいます。
取得時は実体のテーブルファイルを見に行くので、インデックスが活用されるかどうかはテーブルファイルでのデータの位置を特定できるかどうかにつながります。
ではインデックスデータはどのように保存されているのでしょうか。

まず先程作成したテーブルにインデックスを作り、ファイルノード番号を取得します。
インデックスのファイルノード番号もテーブルと同じくpg_classから取得でき、またbaseディレクトリに同じファイル名で保存されています。

```sql
create index on sample (id);
select relname, relfilenode from pg_class where relname = 'sample_id_idx';
    relname    | relfilenode
---------------+-------------
 sample_id_idx |       16390
```

今回も`base/13091`ディレクトリで探してみます。

```sh
$ ls -la ./base/13091/ | grep 16390
-rw------- 1 postgres postgres  16384 May 24 15:36 16390
```

あった。
今回ははじめから16384バイト存在しています。
インデックスファイルもテーブルファイルと同じく8192バイトのページ単位で構成されているので、今回はすでに2ページ存在していることがわかります。
インデックスファイルは下記のようなページ種があるツリー構造になっています。

|名称|説明|
|:--|:--|
|メタページ|インデックスファイルの先頭。制御用の情報が格納されている|
|ルートページ|メタページを除くすべてのページの先頭。ここから検索を始める|
|リーフページ|木構造の葉となるページ。テーブルファイルへのポインタを持つ|
|インターナルページ|ルートページとリーフページの間に存在するページ|

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/65636/307b9778-a590-d314-3395-b770faf71722.png)

### シーケンシャルアクセスとインデックスアクセス

シーケンシャルアクセスとは、インデックスを使用せずテーブルファイルを全ページを順番に見てアクセスする方法です。上で述べたように、テーブルファイルのページはテーブルの全レコードのタプルにとどまらず更新、削除ごとにタプルが追加されているので、挿入・更新・削除が頻繁に行われるテーブルほどシーケンシャルアクセスは遅くなってしまいます。

インデックスアクセスとは、インデックスページの木構造により、ルートから順々に目的のリーフまで辿っていき、リーフには格納されているテーブルファイルのポインタからアクセスする方法です。
二分探索的にアクセスできるのでテーブルファイルを全走査するより当然高速であり、これはテーブルファイルのページ量が増えるほど顕著になっていきます。
テーブルの全レコード数が少量だったり、取得する行数が大きい場合にはインデックスアクセスの方が遅くなってしまうのはイメージができると思います。
もっとも、そのような場合にはオプティマイザがインデックスアクセスを選択しませんが、インデックスファイルを作る分のコストもあるので、不要なインデックスは作成しない方が好ましいです。

## まとめ

- テーブルファイルはページ単位で構成されており、挿入・更新・削除の度にページ内のアイテムは増加する
- ログ先行書き込みの仕組みにより、コミット時にはWALバッファからWALファイルに書き込みされる
- テーブルファイルにはCHECKPOINT実行時やwriterプロセスの定期実行などであとでまとめて書き込まれる
- インデックスファイルによりテーブルファイルの特定のポインタに高速にアクセスできる
